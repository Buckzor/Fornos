
#define FLT_MAX 3.402823466e+38

struct BVH
{
	vec3 c; // Center
	vec3 s; // Half size
	float _pad;
	uint start;
	uint end;
	uint left; // Index to left division
	uint right; // Index to right division
};

float RayAABB(vec3 o, vec3 d, vec3 c, vec3 s)
{
	vec3 mins = c - s;
	vec3 maxs = c + s;
	vec3 dabs = abs(d);
	if (dabs.x < 0.0001) d.x = 0.0001;
	if (dabs.y < 0.0001) d.y = 0.0001;
	if (dabs.z < 0.0001) d.z = 0.0001;
	vec3 t1 = (mins - o) / d;
	vec3 t2 = (maxs - o) / d;
	vec3 tmin = min(t1, t2);
	vec3 tmax = max(t1, t2);
	float a = max(tmin.x, max(tmin.y, tmin.z));
	float b = min(tmax.x, min(tmax.y, tmax.z));
	return (b >= 0 && a <= b) ? a : FLT_MAX;
}

vec3 barycentric(vec3 p, vec3 a, vec3 b, vec3 c)
{
	vec3 v0 = b - a;
	vec3 v1 = c - a;
	vec3 v2 = p - a;
	float d00 = dot(v0, v0);
	float d01 = dot(v0, v1);
	float d11 = dot(v1, v1);
	float d20 = dot(v2, v0);
	float d21 = dot(v2, v1);
	float denom = d00 * d11 - d01 * d01;
	//if (abs(denom) < 0.00001) return vec3(-1,-1,-1);
	float y = (d11 * d20 - d01 * d21) / denom;
	float z = (d00 * d21 - d01 * d20) / denom;
	return vec3(1.0 - y - z, y, z);
}

// Returns distance (x) + barycentric coordinates (yzw)
vec4 raycast(vec3 o, vec3 d, vec3 a, vec3 b, vec3 c)
{
	vec3 n = normalize(cross(b - a, c - a));
	float nd = dot(d, n);
	if (nd > 0.0f)
	{
		float pn = dot(o, n);
		float t = (dot(a, n) - pn) / nd;
		if (t >= 0.0f)
		{
			vec3 p = o + d * t;
			vec3 b = barycentric(p, a, b, c);
			if (b.x >= 0 && b.x <= 1 && 
				b.y >= 0 && b.y <= 1 && 
				b.z >= 0 && b.z <= 1)
			{
				return vec4(t, b.x, b.y, b.z);
			}
		}
	}
	return vec4(FLT_MAX, 0, 0, 0);
}

float raycastRange(vec3 o, vec3 d, uint start, uint end, float mindist, out uint o_idx, out vec3 o_bcoord)
{
	float mint = FLT_MAX;
	for (uint tidx = start; tidx < end; tidx += 3)
	{
		vec3 v0 = positions[tidx + 0];
		vec3 v1 = positions[tidx + 1];
		vec3 v2 = positions[tidx + 2];
		vec4 r = raycast(o, d, v0, v1, v2);
		if (r.x >= mindist && r.x < mint)
		{
			mint = r.x;
			o_idx = tidx;
			o_bcoord = r.yzw;
		}
	}
	return mint;
}

float raycastBVH(vec3 o, vec3 d, float mint, out uint o_idx, out vec3 o_bcoord)
{
	uint i = 0;
	while (i < bvhCount)
	{
		BVH bvh = bvhs[i];
		float distAABB = RayAABB(o, d, bvh.c, bvh.s);
		if (distAABB < mint)
		//if (distAABB != FLT_MAX)
		{
			uint ridx = 0;
			vec3 rbcoord = vec3(0, 0, 0);
			float t = raycastRange(o, d, bvh.start, bvh.end, 0, ridx, rbcoord);
			if (t < mint)
			{
				mint = t;
				o_idx = ridx;
				o_bcoord = rbcoord;
			}
			mint = min(t, mint);
			++i;
		}
		else
		{
			i = bvh.right; // Jump forward
		}
	}

	return mint;
}

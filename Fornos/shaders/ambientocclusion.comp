#version 430 core
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

layout (local_size_x = 64) in;

#define BUFFER_PARAMS 3
#define BUFFER_PIXELS 4
#define BUFFER_POSITIONS 12
#define BUFFER_NORMALS 7
#define BUFFER_BVH 8
#define BUFFER_COORDS 9
#define BUFFER_TIDX 10
#define BUFFER_SAMPLES 13
#define BUFFER_RESULTS_ACC 11

#define FLT_MAX 3.402823466e+38

#define AO_USE_TEXTURES 0

struct Params
{
	uint sampleCount; // Number of rays to sample
	float minDistance;
	float maxDistance;
};

struct Pixel
{
	vec3 p;
	vec3 n;
};

struct BVH
{
	float aabbMinX; float aabbMinY; float aabbMinZ;
	float aabbMaxX; float aabbMaxY; float aabbMaxZ;
	uint start;
	uint end;
	uint jump; // Index to the next BVH if we skip this subtree
};

struct V3
{
	float x;
	float y;
	float z;
};

layout(location = 1) uniform uint workOffset;
layout(location = 2) uniform uint bvhCount;
layout(location = 16) uniform uint sampleIndex;
layout(location = 14) uniform uint samplePermCount;
#if AO_USE_TEXTURES
layout(location = 15) uniform uint texw;
#endif
layout(std430, binding = BUFFER_PARAMS) readonly buffer paramsBuffer { Params params; };
layout(std430, binding = BUFFER_PIXELS) readonly buffer pixBuffer { Pixel pixels[]; };
layout(std430, binding = BUFFER_POSITIONS) readonly buffer meshPBuffer { vec3 positions[]; };
layout(std430, binding = BUFFER_NORMALS) readonly buffer meshNBuffer { vec3 normals[]; };
layout(std430, binding = BUFFER_BVH) readonly buffer bvhBuffer { BVH bvhs[]; };
layout(std430, binding = BUFFER_COORDS) readonly buffer coordsBuffer { vec4 coords[]; };
layout(std430, binding = BUFFER_TIDX) readonly buffer coordsTidxBuffer { uint coords_tidx[]; };
layout(std430, binding = BUFFER_SAMPLES) readonly buffer samplesBuffer { vec3 samples[]; };
#if AO_USE_TEXTURES
layout(r32ui, binding = 0) uniform uimage2D resultsAcc;
#else
layout(std430, binding = BUFFER_RESULTS_ACC) buffer resultAccBuffer { float resultsAcc[]; };
#endif

float RayAABB(vec3 o, vec3 d, vec3 mins, vec3 maxs)
{
	vec3 dabs = abs(d);
	//if (dabs.x < 0.0001) d.x = 0.0001;
	//if (dabs.y < 0.0001) d.y = 0.0001;
	//if (dabs.z < 0.0001) d.z = 0.0001;
	vec3 t1 = (mins - o) / d;
	vec3 t2 = (maxs - o) / d;
	vec3 tmin = min(t1, t2);
	vec3 tmax = max(t1, t2);
	float a = max(tmin.x, max(tmin.y, tmin.z));
	float b = min(tmax.x, min(tmax.y, tmax.z));
	return (b >= 0 && a <= b) ? a : FLT_MAX;
}

vec3 barycentric(vec3 p, vec3 a, vec3 b, vec3 c)
{
	vec3 v0 = b - a;
	vec3 v1 = c - a;
	vec3 v2 = p - a;
	float d00 = dot(v0, v0);
	float d01 = dot(v0, v1);
	float d11 = dot(v1, v1);
	float d20 = dot(v2, v0);
	float d21 = dot(v2, v1);
	float denom = d00 * d11 - d01 * d01;
	//if (abs(denom) < 0.00001) return vec3(-1,-1,-1);
	float y = (d11 * d20 - d01 * d21) / denom;
	float z = (d00 * d21 - d01 * d20) / denom;
	return vec3(1.0 - y - z, y, z);
}

// Returns distance (x) + barycentric coordinates (yzw)
float raycast(vec3 o, vec3 d, vec3 a, vec3 b, vec3 c)
{
	vec3 n = normalize(cross(b - a, c - a));
	float nd = dot(d, n);
	if (abs(nd) > 0)
	{
		float pn = dot(o, n);
		float t = (dot(a, n) - pn) / nd;
		if (t >= 0)
		{
			vec3 p = o + d * t;
			vec3 b = barycentric(p, a, b, c);
			if (b.x >= 0 && //b.x <= 1 &&
				b.y >= 0 && b.y <= 1 &&
				b.z >= 0 && b.z <= 1)
			{
				return t;
			}
		}
	}
	return FLT_MAX;
}

float raycastRange(vec3 o, vec3 d, uint start, uint end, float mindist)
{
	float mint = FLT_MAX;
	for (uint tidx = start; tidx < end; tidx += 3)
	{
		vec3 v0 = positions[tidx + 0];
		vec3 v1 = positions[tidx + 1];
		vec3 v2 = positions[tidx + 2];
		float t = raycast(o, d, v0, v1, v2);
		//float t = raycast_precomp(o, d, tidx, mindist);
		if (t >= mindist && t < mint)
		{
			mint = t;
		}
	}
	return mint;
}

float raycastBVH(vec3 o, vec3 d, float mindist, float maxdist)
{
	float mint = FLT_MAX;
	uint i = 0;
	while (i < bvhCount)
	{
		BVH bvh = bvhs[i];
		vec3 aabbMin = vec3(bvh.aabbMinX, bvh.aabbMinY, bvh.aabbMinZ);
		vec3 aabbMax = vec3(bvh.aabbMaxX, bvh.aabbMaxY, bvh.aabbMaxZ);
		float distAABB = RayAABB(o, d, aabbMin, aabbMax);
		if (distAABB < mint && distAABB < maxdist)
		//if (distAABB != FLT_MAX)
		{
			float t = raycastRange(o, d, bvh.start, bvh.end, mindist);
			if (t < mint)
			{
				mint = t;
			}
			++i;
		}
		else
		{
			i = bvh.jump;
		}
	}

	return mint;
}

// Gets the position from the triangle index and the barycentric coordinates
vec3 getPosition(uint tidx, vec3 bcoord)
{
	vec3 p0 = positions[tidx + 0];
	vec3 p1 = positions[tidx + 1];
	vec3 p2 = positions[tidx + 2];
	return bcoord.x * p0 + bcoord.y * p1 + bcoord.z * p2;
}

vec3 getNormal(uint tidx, vec3 bcoord)
{
	vec3 n0 = normals[tidx + 0];
	vec3 n1 = normals[tidx + 1];
	vec3 n2 = normals[tidx + 2];
	return normalize(bcoord.x * n0 + bcoord.y * n1 + bcoord.z * n2);
}

void main()
{
	uint gid = gl_GlobalInvocationID.x + workOffset;
	vec4 coord = coords[gid];
	uint tidx = coords_tidx[gid];
	vec3 o = getPosition(tidx, coord.yzw);
	vec3 d = getNormal(tidx, coord.yzw);

#if 0
	vec3 up = abs(d.y) < 0.99 ? vec3(0,1,0) : vec3(0,0,-1);
	vec3 tx = normalize(cross(up, d));
	vec3 ty = cross(d, tx);
#else
	vec3 ty = normalize(abs(d.x) > abs(d.y) ? vec3(d.z, 0, -d.x) : vec3(0, d.z, -d.y));
	vec3 tx = cross(d, ty);
#endif

	uint sampleIdx = (gid % samplePermCount) * params.sampleCount + sampleIndex;
#if 1
	vec3 rs = samples[sampleIdx];
#else
	vec3 sa = samples[sampleIdx];
	// Apply a 2d rotation
	float angle = float(gid) * 57.123;
	float a_sin = sin(angle);
	float a_cos = cos(angle);
	vec3 rs = vec3(a_cos * sa.x - a_sin * sa.y, a_sin * sa.x + a_cos * sa.y, sa.z);
#endif

	vec3 sampleDir = normalize(tx * rs.x + ty * rs.y + d * rs.z);
	float t = raycastBVH(o, sampleDir, params.minDistance, params.maxDistance);
	if (t != FLT_MAX && t < params.maxDistance)
	{
		//
#if AO_USE_TEXTURES
		ivec2 iv = ivec2(gid % texw, gid / texw);
		imageAtomicAdd(resultsAcc, iv, 1);
		//imageStore(resultsAcc, iv, imageLoad(resultsAcc, iv) + ivec4(1,1,1,1));
#else
		resultsAcc[gid] += 1.0;
#endif
	}
}
#version 430 core
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

layout (local_size_x = 64) in;

#define BUFFER_PIXELS 4
#define BUFFER_PIXELST 5
#define BUFFER_POSITIONS 12
#define BUFFER_NORMALS 7
#define BUFFER_BVH 8
#define BUFFER_COORDS 9
#define BUFFER_TIDX 10
#define BUFFER_RESULTS 11

#define FLT_MAX 3.402823466e+38

#define TANGENT_SPACE 0

struct Pixel
{
	vec3 p;
	vec3 n;
};

struct PixelT
{
	vec3 t;
	vec3 b;
};

struct BVH
{
	float aabbMinX; float aabbMinY; float aabbMinZ;
	float aabbMaxX; float aabbMaxY; float aabbMaxZ;
	uint start;
	uint end;
	uint jump; // Index to the next BVH if we skip this subtree
};

layout(location = 1) uniform uint workOffset;
layout(location = 2) uniform uint bvhCount;
layout(std430, binding = BUFFER_PIXELS) readonly buffer pixBuffer { Pixel pixels[]; };
layout(std430, binding = BUFFER_PIXELST) readonly buffer pixtBuffer { PixelT pixelst[]; };
layout(std430, binding = BUFFER_POSITIONS) readonly buffer meshPBuffer { vec3 positions[]; };
layout(std430, binding = BUFFER_NORMALS) readonly buffer meshNBuffer { vec3 normals[]; };
layout(std430, binding = BUFFER_BVH) readonly buffer bvhBuffer { BVH bvhs[]; };
layout(std430, binding = BUFFER_COORDS) readonly buffer coordsBuffer { vec4 coords[]; };
layout(std430, binding = BUFFER_TIDX) readonly buffer coordsTidxBuffer { uint coords_tidx[]; };
layout(std430, binding = BUFFER_RESULTS) writeonly buffer resultBuffer { float results[]; };

void main()
{
	uint gid = gl_GlobalInvocationID.x + workOffset;
	Pixel pix = pixels[gid];

	vec4 coord = coords[gid];
	uint tidx = coords_tidx[gid];
	vec3 n0 = normals[tidx + 0];
	vec3 n1 = normals[tidx + 1];
	vec3 n2 = normals[tidx + 2];
	vec3 normal = normalize(coord.y * n0 + coord.z * n1 + coord.w * n2);

	uint ridx = gid * 3;
	results[ridx + 0] = normal.x;
	results[ridx + 1] = normal.y;
	results[ridx + 2] = normal.z;
}
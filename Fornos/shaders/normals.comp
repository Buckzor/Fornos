#version 430 core
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

layout (local_size_x = 32) in;

#define BUFFER_PIXELS 4
#define BUFFER_PIXELST 5
#define BUFFER_POSITIONS 12
#define BUFFER_NORMALS 7
#define BUFFER_BVH 8
#define BUFFER_COORDS 9
#define BUFFER_TIDX 10
#define BUFFER_RESULTS 11

#define FLT_MAX 3.402823466e+38

#define TANGENT_SPACE 1

struct Pixel
{
	vec3 p;
	vec3 n;
};

struct PixelT
{
	vec3 t;
	vec3 b;
};

struct BVH
{
	float aabbMinX; float aabbMinY; float aabbMinZ;
	float aabbMaxX; float aabbMaxY; float aabbMaxZ;
	uint start;
	uint end;
	uint jump; // Index to the next BVH if we skip this subtree
};

layout(location = 1) uniform uint workOffset;
layout(location = 2) uniform uint bvhCount;
layout(std430, binding = BUFFER_PIXELS) readonly buffer pixBuffer { Pixel pixels[]; };
layout(std430, binding = BUFFER_PIXELST) readonly buffer pixtBuffer { PixelT pixelst[]; };
layout(std430, binding = BUFFER_POSITIONS) readonly buffer meshPBuffer { vec3 positions[]; };
layout(std430, binding = BUFFER_NORMALS) readonly buffer meshNBuffer { vec3 normals[]; };
layout(std430, binding = BUFFER_BVH) readonly buffer bvhBuffer { BVH bvhs[]; };
layout(std430, binding = BUFFER_COORDS) readonly buffer coordsBuffer { vec4 coords[]; };
layout(std430, binding = BUFFER_TIDX) readonly buffer coordsTidxBuffer { uint coords_tidx[]; };
layout(std430, binding = BUFFER_RESULTS) writeonly buffer resultBuffer { float results[]; };

void main()
{
	uint gid = gl_GlobalInvocationID.x + workOffset;
	Pixel pix = pixels[gid];

	vec4 coord = coords[gid];
	uint tidx = coords_tidx[gid];
	vec3 n0 = normals[tidx + 0];
	vec3 n1 = normals[tidx + 1];
	vec3 n2 = normals[tidx + 2];
	vec3 normal = normalize(coord.y * n0 + coord.z * n1 + coord.w * n2);

#if TANGENT_SPACE
	PixelT pixt = pixelst[gid];
	vec3 n = pix.n;
	vec3 t = pixt.t;
	vec3 b = pixt.b;
	vec3 d0 = vec3(n.z*b.y - n.y*b.z, n.x*b.z - n.z*b.x, n.y*b.x - n.x*b.y);
	vec3 d1 = vec3(t.z*n.y - t.y*n.z, t.x*n.z - n.x*t.z, n.x*t.y - t.x*n.y);
	vec3 d2 = vec3(t.y*b.z - t.z*b.y, t.z*b.x - t.x*b.z, t.x*b.y - t.y*b.x);
	normal = normalize(vec3(dot(normal, d0), dot(normal, d1), dot(normal, d2)));
#endif

	uint ridx = gid * 3;
	results[ridx + 0] = normal.x;
	results[ridx + 1] = normal.y;
	results[ridx + 2] = normal.z;
}
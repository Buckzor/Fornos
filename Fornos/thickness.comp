#version 430 core
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

layout (local_size_x = 64) in;

#define BUFFER_PARAMS 3
#define BUFFER_ORIGINS 4
#define BUFFER_DIRECTIONS 5
#define BUFFER_SAMPLES 6
#define BUFFER_VERTICES 7
#define BUFFER_RESULTS 8

struct Params
{
	uint sampleCount; // Number of rays to sample
	uint vertexCount; // Number of vertices on the mesh
	float minDistance;
	float maxDistance;
};

layout(std430, binding = BUFFER_PARAMS) readonly buffer paramsBuffer
{
	Params params;
};

layout(std430, binding = BUFFER_ORIGINS) readonly buffer orgBuffer
{
	float origins[];
};

layout(std430, binding = BUFFER_DIRECTIONS) readonly buffer dirBuffer
{
	float directions[];
};

layout(std430, binding = BUFFER_SAMPLES) readonly buffer samplesBuffer
{
	float samples[];
};

layout(std430, binding = BUFFER_VERTICES) readonly buffer trisBuffer
{
	float vertices[];
};

layout(std430, binding = BUFFER_RESULTS) writeonly buffer resultBuffer
{
	float results[];
};

void main()
{
	const float epsilon = 1e-6f;

	uint gid = gl_GlobalInvocationID.x;
	uint tidx = gid * 3;
	vec3 o = vec3(origins[tidx], origins[tidx+1], origins[tidx+2]);
	vec3 d0 = vec3(directions[tidx], directions[tidx+1], directions[tidx+2]);

	vec3 up = abs(d0.y) < 0.99 ? vec3(0,1,0) : vec3(0,0,-1);
	vec3 tx = normalize(cross(up, d0));
	vec3 ty = cross(d0, tx);

	vec3 dirs[16];
	for (uint i = 0; i < params.sampleCount * 3; i += 3)
	{
		dirs[i] = normalize(tx * samples[i + 0] + ty * samples[i + 1] + d0 * samples[i + 2]);
	}

	float rAcc = 0;
	float rCount = 0;

	for (uint tidx = 0; tidx < params.vertexCount * 3; tidx += 9)
	{
		vec3 v0 = vec3(vertices[tidx + 0], vertices[tidx + 1], vertices[tidx + 2]);
		vec3 v1 = vec3(vertices[tidx + 3], vertices[tidx + 4], vertices[tidx + 5]);
		vec3 v2 = vec3(vertices[tidx + 6], vertices[tidx + 7], vertices[tidx + 8]);
		vec3 e0 = v1 - v0;
		vec3 e1 = v2 - v0;

		for (int i = 0; i < params.sampleCount; ++i)
		{
			vec3 d = dirs[i];
			vec3 h = cross(d, e1);
			float a = dot(e0, h);
			if (a < -epsilon || a > epsilon)
			{
				float f = 1.0 / a;
				vec3 s = o - v0;
				float u = f * dot(s, h);
				if (u >= 0 && u < 1)
				{
					vec3 q = cross(s, e0);
					float v = f * dot(d, q);
					if (v >= 0 && (u + v) <= 1)
					{
						float t = f * dot(e1, q);
						if (t >= params.minDistance)
						{
							rAcc += min(t, params.maxDistance);
							rCount += 1;
						}
					}
				}
			}
		}
	}

	results[gid] = rAcc / rCount;
	//results[gid] = d0.y;
}